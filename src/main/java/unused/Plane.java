package unused;

import java.io.Serializable;

import au.net.hal9000.heisenberg.units.Point3d;

/**
 * 3D point in space.
 * 
 * @author bruins
 * @version $Revision: 1.0 $
 */
public class Plane implements Serializable, Cloneable {
    /** serial version id. */
    private static final long serialVersionUID = 1L;

    /** comparison tolerance. */
    public static final float DEFAULT_AXIS_TOLERANCE = 0.01f;

    /** x coord. */
    private double a = 0;
    /** y coord. */
    private double b = 0;
    /** z coord. */
    private double c = 0;
    /** c coord. */
    private double d = 0;

    /**
     * Constructor.
     * 
     * @param x
     *            x coord
     * @param y
     *            y coord
     * @param z
     *            z coord
     * @param c
     *            c coord
     */
    public Plane(double x, double y, double z, double c) {
        super();
        this.a = x;
        this.b = y;
        this.c = z;
        this.d = c;
    }

    /**
     * Constructor - no offset.
     */
    public Plane() {
        this(0, 0, 0, 0);
    }

    /**
     * 
     * @return a
     */
    public double getA() {
        return a;
    }

    /**
     * 
     * @param a
     *            value to set
     */
    public void setA(double a) {
        this.a = a;
    }

    /**
     * 
     * @return b
     */
    public double getB() {
        return b;
    }

    /**
     * 
     * @param b
     *            value to set
     */
    public void setB(double b) {
        this.b = b;
    }

    /**
     * 
     * @return c
     */
    public double getC() {
        return c;
    }

    /**
     * 
     * @param c
     *            value to set
     */
    public void setC(double c) {
        this.c = c;
    }

    /**
     * 
     * @return d
     */
    public double getD() {
        return d;
    }

    /**
     * 
     * @param d
     *            value to set
     */
    public void setD(double d) {
        this.d = d;
    }

    /**
     * Method toString.
     * 
     * @return String
     */
    @Override
    public String toString() {
        return String.format("[%.2f, %.2f, %.2f, %.2f]", a, b, c, d);
    }

    /**
     * @param point
     *            other Point3d object.
     * 
     * @return min distance (modulus) to point.
     */
    public double distance(Point3d point) {
        return Math.abs(a * point.getX() + b * point.getY() + c * point.getZ()
                + d)
                / Math.sqrt(a * a + b * b + c * c);
    }

    /**
     * Method clone.
     * 
     * @return Point3d
     */
    @Override
    public Plane clone() throws CloneNotSupportedException {
        final Plane clone = (Plane) super.clone();
        clone.a = a;
        clone.b = b;
        clone.c = c;
        clone.d = d;
        return clone;
    }

    /**
     * Duplicate the object.
     * 
     * @return Plane
     */
    public Plane duplicate() {
        return new Plane(a, b, c, d);
    }

    // Autogenerated
    /**
     * Method hashCode.
     * 
     * @return int
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        long temp;
        temp = Double.doubleToLongBits(a);
        result = prime * result + (int) (temp ^ (temp >>> (prime + 1)));
        temp = Double.doubleToLongBits(b);
        result = prime * result + (int) (temp ^ (temp >>> (prime + 1)));
        temp = Double.doubleToLongBits(c);
        result = prime * result + (int) (temp ^ (temp >>> (prime + 1)));
        return result;
    }

    /**
     * Method equals.
     * 
     * @param obj
     *            Object
     * @return boolean
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (null == obj) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        Plane other = (Plane) obj;
        return equals(other, DEFAULT_AXIS_TOLERANCE);
    }

    /**
     * Return true each difference in x,y,z,c is less than tolerance.
     * 
     * @param other
     *            point we are comparing to.
     * @param tolerance
     *            amount, per axis, where we consider points are different.
     * 
     * @return true on equals.
     */
    public boolean equals(Plane other, double tolerance) {
        if (this == other) {
            return true;
        }
        if (null == other) {
            return false;
        }
        return doubleEqualEnough(a, other.a, tolerance)
                && doubleEqualEnough(b, other.b, tolerance)
                && doubleEqualEnough(c, other.c, tolerance)
                && doubleEqualEnough(d, other.d, tolerance);
    }

    // return true if, and only if, either:
    // 1) equal in terms of double (NaN / +0 / -0 etc.)
    // 2) within tolerance of each other.
    private static boolean doubleEqualEnough(double a, double b,
            double tolerance) {
        return ((Double.doubleToLongBits(a) == Double.doubleToLongBits(b)) || (Math
                .abs(a - b) < tolerance));
    }

}
