package au.net.hal9000.heisenberg.units;

import java.io.Serializable;

/**
 * 3D point in space.
 * @author bruins
 * @version $Revision: 1.0 $
 */
public class Complex implements Serializable, Cloneable {
    /** serial version id. */
    private static final long serialVersionUID = 1L;

    /** comparison tolerance. */
    static final float TOLERANCE = 0.01f;

    /** real component. */
    private double real = 0;
    /** imaginary component. */
    private double img = 0;

    /**
    
     * @return get the tolerance. */
    public static float getTolerance() {
        return TOLERANCE;
    }

    /**
     * Constructor.
     * 
     * @param real
     *            real component
     * @param img
     *            imaginary component
     */
    public Complex(double real, double img) {
        super();
        this.real = real;
        this.img = img;
    }

    /**
     * Constructor - no offset.
     */
    public Complex() {
        this(0, 0);
    }

    /**
     * 
    
     * @return get real component. */
    public double getReal() {
        return real;
    }

    /**
     * 
     * @param real
     *            set new real component.
     */

    public void setReal(double real) {
        this.real = real;
    }

    /**
     * 
    
     * @return get imaginary component. */
    public double getImg() {
        return img;
    }

    /**
     * 
     * @param img
     *            set new imaginary component.
     */
    public void setImg(double img) {
        this.img = img;
    }

    /**
     * Method toString.
     * @return String
     */
    @Override
    public String toString() {
        return String.format("[r=%.2f,i=%.2f]", real, img);
    }

    /**
     * @param other
     *            other Complex object.
    
     * @return distance (modulus) to other point. */
    public double distance(Complex other) {
        return Math.sqrt(Math.pow(real - other.real, 2.0)
                + Math.pow(img - other.img, 2.0));
    }

    /**
     * @param other
     *            other Complex object.
    
     * @return delta (change in position) to other point. */
    public Complex delta(Complex other) {
        return new Complex(real - other.real, img - other.img);
    }

    /**
     * Method clone.
     * @return Complex
     * @throws CloneNotSupportedException
     */
    @Override
    public Complex clone() throws CloneNotSupportedException {
        Complex clone = (Complex) super.clone();
        clone.real = real;
        clone.img = img;
        return clone;
    }

    // Autogenerated
    /**
     * Method hashCode.
     * @return int
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        long temp;
        temp = Double.doubleToLongBits(img);
        result = prime * result + (int) (temp ^ (temp >>> (prime + 1)));
        temp = Double.doubleToLongBits(real);
        result = prime * result + (int) (temp ^ (temp >>> (prime + 1)));
        return result;
    }

    // Autogenerated
    /**
     * Method equals.
     * @param obj Object
     * @return boolean
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (null == obj) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        Complex other = (Complex) obj;
        if (Double.doubleToLongBits(img) != Double.doubleToLongBits(other.img)) {
            return false;
        }
        if (Double.doubleToLongBits(real) != Double
                .doubleToLongBits(other.real)) {
            return false;
        }
        return true;
    }

    /**
     * Apply movement delta to this 3D point.
     * 
     * @param delta
     *            amount of movement
     */
    public void applyDelta(Complex delta) {
        real += delta.getReal();
        img += delta.getImg();
    }

    /**
     * Create a new object with a sum of this object and the delta.
     * 
     * @param delta
     *            amount of movement
    
     * @return new object with delta applied. */
    public Complex newWithDelta(Complex delta) {
        return new Complex(real + delta.getReal(), img + delta.getImg());
    }

}
