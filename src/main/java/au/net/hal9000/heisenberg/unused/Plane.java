package au.net.hal9000.heisenberg.unused;

import java.io.Serializable;

import au.net.hal9000.heisenberg.units.Point3d;

/**
 * 3D point in space.
 * 
 * @author bruins
 * @version $Revision: 1.0 $
 */
public class Plane implements Serializable, Cloneable {
    /** serial version id. */
    private static final long serialVersionUID = 1L;

    /** comparison tolerance. */
    public static final float DEFAULT_AXIS_TOLERANCE = 0.01f;

    /** x coord. */
    private double xCoord = 0;
    /** y coord. */
    private double yCoord = 0;
    /** z coord. */
    private double zCoord = 0;
    /** c value. */
    private double cValue = 0;

    /**
     * Constructor.
     * 
     * @param x
     *            x coord
     * @param y
     *            y coord
     * @param z
     *            z coord
     * @param c
     *            c value
     */
    public Plane(double x, double y, double z, double c) {
        super();
        this.xCoord = x;
        this.yCoord = y;
        this.zCoord = z;
        this.cValue = c;
    }

    /**
     * Constructor - no offset.
     */
    public Plane() {
        this(0, 0, 0, 0);
    }

    /**
     * 
     * @return x
     */
    public double getX() {
        return xCoord;
    }

    /**
     * 
     * @param x
     *            value to set
     */
    public void setX(double x) {
        this.xCoord = x;
    }

    /**
     * 
     * @return y
     */
    public double getY() {
        return yCoord;
    }

    /**
     * 
     * @param y
     *            value to set
     */
    public void setY(double y) {
        this.yCoord = y;
    }

    /**
     * 
     * @return z
     */
    public double getZ() {
        return zCoord;
    }

    /**
     * 
     * @param z
     *            value to set
     */
    public void setZ(double z) {
        this.zCoord = z;
    }

    /**
     * 
     * @return c
     */
    public double getC() {
        return cValue;
    }

    /**
     * 
     * @param c
     *            value to set
     */
    public void setC(double c) {
        this.cValue = c;
    }

    /**
     * Method toString.
     * 
     * @return String
     */
    @Override
    public String toString() {
        return String.format("[%.2f, %.2f, %.2f, %.2f]", xCoord, yCoord, zCoord, cValue);
    }

    /**
     * @param point
     *            other Point3d object.
     * 
     * @return min distance (modulus) to point.
     */
    public double distance(Point3d point) {
        return Math.abs(xCoord * point.getX() + yCoord * point.getY() + zCoord * point.getZ()
                + cValue)
                / Math.sqrt(xCoord * xCoord + yCoord * yCoord + zCoord * zCoord);
    }

    /**
     * Method clone.
     * 
     * @return Point3d
     */
    @Override
    public Plane clone() throws CloneNotSupportedException {
        final Plane clone = (Plane) super.clone();
        clone.xCoord = xCoord;
        clone.yCoord = yCoord;
        clone.zCoord = zCoord;
        clone.cValue = cValue;
        return clone;
    }

    /**
     * Duplicate the object.
     * 
     * @return Plane
     */
    public Plane duplicate() {
        return new Plane(xCoord, yCoord, zCoord, cValue);
    }

    // Autogenerated
    /**
     * Method hashCode.
     * 
     * @return int
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        long temp;
        temp = Double.doubleToLongBits(xCoord);
        result = prime * result + (int) (temp ^ (temp >>> (prime + 1)));
        temp = Double.doubleToLongBits(yCoord);
        result = prime * result + (int) (temp ^ (temp >>> (prime + 1)));
        temp = Double.doubleToLongBits(zCoord);
        result = prime * result + (int) (temp ^ (temp >>> (prime + 1)));
        return result;
    }

    /**
     * Method equals.
     * 
     * @param obj
     *            Object
     * @return boolean
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (null == obj) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        Plane other = (Plane) obj;
        return equals(other, DEFAULT_AXIS_TOLERANCE);
    }

    /**
     * Return true each difference in x,y,z,c is less than tolerance.
     * 
     * @param other
     *            point we are comparing to.
     * @param tolerance
     *            amount, per axis, where we consider points are different.
     * 
     * @return true on equals.
     */
    public boolean equals(Plane other, double tolerance) {
        if (this == other) {
            return true;
        }
        if (null == other) {
            return false;
        }
        return isEqualEnough(xCoord, other.getX(), tolerance)
                && isEqualEnough(yCoord, other.getY(), tolerance)
                && isEqualEnough(zCoord, other.getZ(), tolerance)
                && isEqualEnough(cValue, other.getC(), tolerance);
    }

    // return true if, and only if, either:
    // 1) equal in terms of double (NaN / +0 / -0 etc.)
    // 2) within tolerance of each other.
    private static boolean isEqualEnough(double a, double b,
            double tolerance) {
        return ((Double.doubleToLongBits(a) == Double.doubleToLongBits(b)) || (Math
                .abs(a - b) < tolerance));
    }

}
